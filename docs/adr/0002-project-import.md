# Use of Import in project files

## Status

Proposed.

## Context

After moving to a NuGet package approach—see [ADR 0001](./0001-practices-via-nuget.md)—we ran into one of the shortcomings of build infrastructure in NuGet packages. Under the old scheme, we had set the `<RootNamespace>` to be empty in one of our standard files. We moved that into the NuGet package, but it ended up running earlier in the process. It ran before the `Microsoft.NET.Sdk.props` file in in the .NET Core SDK file that sets it to its default value (the same as your project name). This means that although our NuGet package did set it to be empty, the SDK promptly overwrote that with the default value; in the old system, because our file ran later, the SDK went first, and we then set it back to empty.

As far as we can tell, NuGet packages get to inject items into the build process at exactly two places: they can add `.props` files before anything in the main `.csproj` is processed, fairly early on in the MSBuild process, and they can add `.targets` files that run after the main `.csproj` is processed. In each case, NuGet-supplied `.props` and `.targets` files seem to run somewhere in the middle of things—before some SDK elements and after some other SDK elements.

According to https://docs.microsoft.com/en-us/visualstudio/msbuild/customize-your-build?view=vs-2019#customize-all-net-builds there is a mechanism by which you can inject imports at other locations. In theory `CustomAfterMicrosoftCSharpProps` would be ideal, because that would be after the SDK had set the default value, and we could immediately set it back to being empty. There are two snags with this:

1. this is using a global mechanism for the benefit of a single NuGet package—if anything else tries the same trick of setting `CustomAfterMicrosoftCSharpProps`, we're in trouble
1. it turns out not to work anyway—apparently not all of the properties listed in that documentation page are real

We might have been able to live with 1 because this is for use only in our own projects, but 2 is a showstopper.

There don't appear to be any hooks available. We considered some alternatives:

1. live with requiring a `<RootNamespace/>` in all projects (which is where we are at the time of writing this, on v0.1.0 of `Endjin.RecommendedPractices`)
1. use one of the documented hooks on that page that _does_ work; `CustomBeforeMicrosoftCSharpTargets` seems to work, and looked promising
1. require projects to have an `<Import>` at the top that adds in a file from the `Endjin.RecommendedPractices` package

We don't really like 1, and in any case we're likely to see more of this kind of problem as time goes on. The point was to avoid or minimize the amount of boilerplate, so a solution that entails adding one line _per problem_ to every project isn't really acceptable.

2 looked good initially because it avoids boilerplate, but suffers from looking flakey: although it might work today, it relies on nothing in the build process prior to the point at which we get to inject our property relying on `RootNamespace`. By inspection that appears to be true today, but might not always be true. This felt like a build failure waiting to happen. Also, there was no straightforward way for a project to decide it didn't want an empty root namespace. We could have devised an override mechanism, but it felt complex.

3 introduces boilerplate so it's not ideal, but it's better than 1 for the following reasons:

- The boilerplate is self-evidently something to do with endjin practices
- There's no scope for tinkering with it because it just imports something else you can't edit (unlike any other 'standard' settings that just have to be there)
- It provides us with a solution for any similar problems that emerge in the future
- It is easy for us to detect when a project has failed to add the necessary line, and provide an error message explaining exactly what to do

*Note*: at one point we were hoping to solve this by adding a `Directory.props` to the solution. But it turns out that this also loads at the wrong point to solve the `RootNamespace` issue. We really do need to be able to set properties just before, or right at the top of the `csproj`.


## Decision

We are going to require all projects to contain this line at the top of the `csproj`:

```xml
<Import Project="$(EndjinProjectPropsPath)" />
```

To ensure people know they're supposed to have this, we emit an error if it's not present. (The error is generated by a `Target`, so you won't see it until you first build, but you won't be able to get far without fixing it.) In projects where this is omitted, the following error will be shown:

`When using the Endjin.RecommendedPractices NuGet package, you must add <Import Project="$(EndjinProjectPropsPath)" /> at the top of your csproj file`

If it's absolutely necessary, developers can opt out of this by setting `EndjinSuppressPropsImportError` to `true` in their properties ahead of that import.

## Consequences

This has the following benefits:

- Projects using `Endjin.RecommendedPractices` will no longer need to set `<RootNamespace/>`
- Projects that want a non-empty root namespace can still have one, they just need to set it explicitly in the normal way
- New projects using `Endjin.RecommendedPractices` will receive an error message explaining clearly exactly how they need to modify the project file

There is also a downside:

- All project files must have an annoying non-standard `<Import>` at the top (which was exactly the sort of thing we were trying to get away from)